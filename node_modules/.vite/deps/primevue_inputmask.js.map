{
  "version": 3,
  "sources": ["../../src/inputmask/style/InputMaskStyle.js", "../../src/inputmask/BaseInputMask.vue", "../../src/inputmask/InputMask.vue", "../../src/inputmask/InputMask.vue?vue&type=template&id=7ec92431&lang.js"],
  "sourcesContent": ["import BaseStyle from '@primevue/core/base/style';\n\nconst classes = {\n    root: ({ instance }) => [\n        'p-inputmask',\n        {\n            'p-filled': instance.filled\n        }\n    ]\n};\n\nexport default BaseStyle.extend({\n    name: 'inputmask',\n    classes\n});\n", "<script>\nimport BaseComponent from '@primevue/core/basecomponent';\nimport InputMaskStyle from 'primevue/inputmask/style';\n\nexport default {\n    name: 'BaseInputMask',\n    extends: BaseComponent,\n    props: {\n        modelValue: null,\n        slotChar: {\n            type: String,\n            default: '_'\n        },\n        class: {\n            type: [String, Object],\n            default: null\n        },\n        mask: {\n            type: String,\n            default: null\n        },\n        placeholder: {\n            type: String,\n            default: null\n        },\n        autoClear: {\n            type: Boolean,\n            default: true\n        },\n        unmask: {\n            type: Boolean,\n            default: false\n        },\n        readonly: {\n            type: Boolean,\n            default: false\n        },\n        invalid: {\n            type: Boolean,\n            default: false\n        },\n        disabled: {\n            type: Boolean,\n            default: false\n        },\n        variant: {\n            type: String,\n            default: null\n        },\n        fluid: {\n            type: Boolean,\n            default: false\n        }\n    },\n    style: InputMaskStyle,\n    provide() {\n        return {\n            $pcInputMask: this,\n            $parentInstance: this\n        };\n    }\n};\n</script>\n", "<template>\n    <InputText\n        :value=\"modelValue\"\n        :class=\"inputClass\"\n        :readonly=\"readonly\"\n        :disabled=\"disabled\"\n        :invalid=\"invalid\"\n        :variant=\"variant\"\n        :placeholder=\"placeholder\"\n        :fluid=\"fluid\"\n        :unstyled=\"unstyled\"\n        @input=\"onInput\"\n        @focus=\"onFocus\"\n        @blur=\"onBlur\"\n        @keydown=\"onKeyDown\"\n        @keypress=\"onKeyPress\"\n        @paste=\"onPaste\"\n        :pt=\"ptmi('root', ptmParams)\"\n    />\n</template>\n\n<script>\nimport { getUserAgent } from '@primeuix/utils/dom';\nimport InputText from 'primevue/inputtext';\nimport BaseInputMask from './BaseInputMask.vue';\n\nexport default {\n    name: 'InputMask',\n    extends: BaseInputMask,\n    inheritAttrs: false,\n    emits: ['update:modelValue', 'focus', 'blur', 'keydown', 'complete', 'keypress', 'paste'],\n    watch: {\n        mask(newMask, oldMask) {\n            if (oldMask !== newMask) {\n                this.initMask();\n            }\n        }\n    },\n    mounted() {\n        this.initMask();\n    },\n    updated() {\n        if (this.isValueUpdated()) {\n            this.updateValue();\n        }\n    },\n    methods: {\n        onInput(event) {\n            if (this.androidChrome) this.handleAndroidInput(event);\n            else this.handleInputChange(event);\n\n            this.$emit('update:modelValue', event.target.value);\n        },\n        onFocus(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            this.focus = true;\n\n            clearTimeout(this.caretTimeoutId);\n            let pos;\n\n            this.focusText = this.$el.value;\n\n            pos = this.checkVal();\n\n            this.caretTimeoutId = setTimeout(() => {\n                if (this.$el !== document.activeElement) {\n                    return;\n                }\n\n                this.writeBuffer();\n\n                if (pos === this.mask.replace('?', '').length) {\n                    this.caret(0, pos);\n                } else {\n                    this.caret(pos);\n                }\n            }, 10);\n\n            this.$emit('focus', event);\n        },\n        onBlur(event) {\n            this.focus = false;\n            this.checkVal();\n            this.updateModel(event);\n\n            if (this.$el.value !== this.focusText) {\n                let e = document.createEvent('HTMLEvents');\n\n                e.initEvent('change', true, false);\n                this.$el.dispatchEvent(e);\n            }\n\n            this.$emit('blur', event);\n        },\n        onKeyDown(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            let k = event.code,\n                pos,\n                begin,\n                end;\n            let iPhone = /iphone/i.test(getUserAgent());\n\n            this.oldVal = this.$el.value;\n\n            //backspace, delete, and escape get special treatment\n            if (k === 'Backspace' || k === 'Delete' || (iPhone && k === 'Escape')) {\n                pos = this.caret();\n                begin = pos.begin;\n                end = pos.end;\n\n                if (end - begin === 0) {\n                    begin = k !== 'Delete' ? this.seekPrev(begin) : (end = this.seekNext(begin - 1));\n                    end = k === 'Delete' ? this.seekNext(end) : end;\n                }\n\n                this.clearBuffer(begin, end);\n                this.shiftL(begin, end - 1);\n                this.updateModel(event);\n\n                event.preventDefault();\n            } else if (k === 'Enter') {\n                // enter\n                this.$el.blur();\n                this.updateModel(event);\n            } else if (k === 'Escape') {\n                // escape\n                this.$el.value = this.focusText;\n                this.caret(0, this.checkVal());\n                this.updateModel(event);\n                event.preventDefault();\n            }\n\n            this.$emit('keydown', event);\n        },\n        onKeyPress(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            var k = event.code,\n                pos = this.caret(),\n                p,\n                c,\n                next,\n                completed;\n\n            if (event.ctrlKey || event.altKey || event.metaKey || event.shiftKey || event.key === 'CapsLock' || event.key === 'Escape' || event.key === 'Tab') {\n                //Ignore\n                return;\n            } else if (k && k !== 'Enter') {\n                if (pos.end - pos.begin !== 0) {\n                    this.clearBuffer(pos.begin, pos.end);\n                    this.shiftL(pos.begin, pos.end - 1);\n                }\n\n                p = this.seekNext(pos.begin - 1);\n\n                if (p < this.len) {\n                    c = event.key;\n\n                    if (this.tests[p].test(c)) {\n                        this.shiftR(p);\n\n                        this.buffer[p] = c;\n                        this.writeBuffer();\n                        next = this.seekNext(p);\n\n                        if (/android/i.test(getUserAgent())) {\n                            //Path for CSP Violation on FireFox OS 1.1\n                            let proxy = () => {\n                                this.caret(next);\n                            };\n\n                            setTimeout(proxy, 0);\n                        } else {\n                            this.caret(next);\n                        }\n\n                        if (pos.begin <= this.lastRequiredNonMaskPos) {\n                            completed = this.isCompleted();\n                        }\n                    }\n                }\n\n                event.preventDefault();\n            }\n\n            this.updateModel(event);\n\n            if (completed) {\n                this.$emit('complete', event);\n            }\n\n            this.$emit('keypress', event);\n        },\n        onPaste(event) {\n            this.handleInputChange(event);\n\n            this.$emit('paste', event);\n        },\n        caret(first, last) {\n            let range, begin, end;\n\n            if (!this.$el.offsetParent || this.$el !== document.activeElement) {\n                return;\n            }\n\n            if (typeof first === 'number') {\n                begin = first;\n                end = typeof last === 'number' ? last : begin;\n\n                if (this.$el.setSelectionRange) {\n                    this.$el.setSelectionRange(begin, end);\n                } else if (this.$el['createTextRange']) {\n                    range = this.$el['createTextRange']();\n                    range.collapse(true);\n                    range.moveEnd('character', end);\n                    range.moveStart('character', begin);\n                    range.select();\n                }\n            } else {\n                if (this.$el.setSelectionRange) {\n                    begin = this.$el.selectionStart;\n                    end = this.$el.selectionEnd;\n                } else if (document['selection'] && document['selection'].createRange) {\n                    range = document['selection'].createRange();\n                    begin = 0 - range.duplicate().moveStart('character', -100000);\n                    end = begin + range.text.length;\n                }\n\n                return { begin: begin, end: end };\n            }\n        },\n        isCompleted() {\n            for (let i = this.firstNonMaskPos; i <= this.lastRequiredNonMaskPos; i++) {\n                if (this.tests[i] && this.buffer[i] === this.getPlaceholder(i)) {\n                    return false;\n                }\n            }\n\n            return true;\n        },\n        getPlaceholder(i) {\n            if (i < this.slotChar.length) {\n                return this.slotChar.charAt(i);\n            }\n\n            return this.slotChar.charAt(0);\n        },\n        seekNext(pos) {\n            while (++pos < this.len && !this.tests[pos]);\n\n            return pos;\n        },\n        seekPrev(pos) {\n            while (--pos >= 0 && !this.tests[pos]);\n\n            return pos;\n        },\n        shiftL(begin, end) {\n            let i, j;\n\n            if (begin < 0) {\n                return;\n            }\n\n            for (i = begin, j = this.seekNext(end); i < this.len; i++) {\n                if (this.tests[i]) {\n                    if (j < this.len && this.tests[i].test(this.buffer[j])) {\n                        this.buffer[i] = this.buffer[j];\n                        this.buffer[j] = this.getPlaceholder(j);\n                    } else {\n                        break;\n                    }\n\n                    j = this.seekNext(j);\n                }\n            }\n\n            this.writeBuffer();\n            this.caret(Math.max(this.firstNonMaskPos, begin));\n        },\n        shiftR(pos) {\n            let i, c, j, t;\n\n            for (i = pos, c = this.getPlaceholder(pos); i < this.len; i++) {\n                if (this.tests[i]) {\n                    j = this.seekNext(i);\n                    t = this.buffer[i];\n                    this.buffer[i] = c;\n\n                    if (j < this.len && this.tests[j].test(t)) {\n                        c = t;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        },\n        handleAndroidInput(event) {\n            var curVal = this.$el.value;\n            var pos = this.caret();\n\n            if (this.oldVal && this.oldVal.length && this.oldVal.length > curVal.length) {\n                // a deletion or backspace happened\n                this.checkVal(true);\n                while (pos.begin > 0 && !this.tests[pos.begin - 1]) pos.begin--;\n\n                if (pos.begin === 0) {\n                    while (pos.begin < this.firstNonMaskPos && !this.tests[pos.begin]) pos.begin++;\n                }\n\n                this.caret(pos.begin, pos.begin);\n            } else {\n                this.checkVal(true);\n                while (pos.begin < this.len && !this.tests[pos.begin]) pos.begin++;\n\n                this.caret(pos.begin, pos.begin);\n            }\n\n            if (this.isCompleted()) {\n                this.$emit('complete', event);\n            }\n        },\n        clearBuffer(start, end) {\n            let i;\n\n            for (i = start; i < end && i < this.len; i++) {\n                if (this.tests[i]) {\n                    this.buffer[i] = this.getPlaceholder(i);\n                }\n            }\n        },\n        writeBuffer() {\n            this.$el.value = this.buffer.join('');\n        },\n        checkVal(allow) {\n            this.isValueChecked = true;\n            //try to place characters where they belong\n            let test = this.$el.value,\n                lastMatch = -1,\n                i,\n                c,\n                pos;\n\n            for (i = 0, pos = 0; i < this.len; i++) {\n                if (this.tests[i]) {\n                    this.buffer[i] = this.getPlaceholder(i);\n\n                    while (pos++ < test.length) {\n                        c = test.charAt(pos - 1);\n\n                        if (this.tests[i].test(c)) {\n                            this.buffer[i] = c;\n                            lastMatch = i;\n                            break;\n                        }\n                    }\n\n                    if (pos > test.length) {\n                        this.clearBuffer(i + 1, this.len);\n                        break;\n                    }\n                } else {\n                    if (this.buffer[i] === test.charAt(pos)) {\n                        pos++;\n                    }\n\n                    if (i < this.partialPosition) {\n                        lastMatch = i;\n                    }\n                }\n            }\n\n            if (allow) {\n                this.writeBuffer();\n            } else if (lastMatch + 1 < this.partialPosition) {\n                if (this.autoClear || this.buffer.join('') === this.defaultBuffer) {\n                    // Invalid value. Remove it and replace it with the\n                    // mask, which is the default behavior.\n                    if (this.$el.value) this.$el.value = '';\n                    this.clearBuffer(0, this.len);\n                } else {\n                    // Invalid value, but we opt to show the value to the\n                    // user and allow them to correct their mistake.\n                    this.writeBuffer();\n                }\n            } else {\n                this.writeBuffer();\n                this.$el.value = this.$el.value.substring(0, lastMatch + 1);\n            }\n\n            return this.partialPosition ? i : this.firstNonMaskPos;\n        },\n        handleInputChange(event) {\n            const isPasteEvent = event.type === 'paste';\n\n            if (this.readonly || isPasteEvent) {\n                return;\n            }\n\n            var pos = this.checkVal(true);\n\n            this.caret(pos);\n            this.updateModel(event);\n\n            if (this.isCompleted()) {\n                this.$emit('complete', event);\n            }\n        },\n        getUnmaskedValue() {\n            let unmaskedBuffer = [];\n\n            for (let i = 0; i < this.buffer.length; i++) {\n                let c = this.buffer[i];\n\n                if (this.tests[i] && c !== this.getPlaceholder(i)) {\n                    unmaskedBuffer.push(c);\n                }\n            }\n\n            return unmaskedBuffer.join('');\n        },\n        updateModel(e) {\n            let val = this.unmask ? this.getUnmaskedValue() : e.target.value;\n\n            this.$emit('update:modelValue', this.defaultBuffer !== val ? val : '');\n        },\n        updateValue(updateModel = true) {\n            if (this.$el) {\n                if (this.modelValue == null) {\n                    this.$el.value = '';\n                    updateModel && this.$emit('update:modelValue', '');\n                } else {\n                    this.$el.value = this.modelValue;\n                    this.checkVal();\n\n                    setTimeout(() => {\n                        if (this.$el) {\n                            this.writeBuffer();\n                            this.checkVal();\n\n                            if (updateModel) {\n                                let val = this.unmask ? this.getUnmaskedValue() : this.$el.value;\n\n                                this.$emit('update:modelValue', this.defaultBuffer !== val ? val : '');\n                            }\n                        }\n                    }, 10);\n                }\n\n                this.focusText = this.$el.value;\n            }\n        },\n        initMask() {\n            this.tests = [];\n            this.partialPosition = this.mask.length;\n            this.len = this.mask.length;\n            this.firstNonMaskPos = null;\n            this.defs = {\n                9: '[0-9]',\n                a: '[A-Za-z]',\n                '*': '[A-Za-z0-9]'\n            };\n\n            let ua = getUserAgent();\n\n            this.androidChrome = /chrome/i.test(ua) && /android/i.test(ua);\n\n            let maskTokens = this.mask.split('');\n\n            for (let i = 0; i < maskTokens.length; i++) {\n                let c = maskTokens[i];\n\n                if (c === '?') {\n                    this.len--;\n                    this.partialPosition = i;\n                } else if (this.defs[c]) {\n                    this.tests.push(new RegExp(this.defs[c]));\n\n                    if (this.firstNonMaskPos === null) {\n                        this.firstNonMaskPos = this.tests.length - 1;\n                    }\n\n                    if (i < this.partialPosition) {\n                        this.lastRequiredNonMaskPos = this.tests.length - 1;\n                    }\n                } else {\n                    this.tests.push(null);\n                }\n            }\n\n            this.buffer = [];\n\n            for (let i = 0; i < maskTokens.length; i++) {\n                let c = maskTokens[i];\n\n                if (c !== '?') {\n                    if (this.defs[c]) this.buffer.push(this.getPlaceholder(i));\n                    else this.buffer.push(c);\n                }\n            }\n\n            this.defaultBuffer = this.buffer.join('');\n            this.updateValue(false);\n        },\n        isValueUpdated() {\n            return this.unmask ? this.modelValue != this.getUnmaskedValue() : this.defaultBuffer !== this.$el.value && this.$el.value !== this.modelValue;\n        }\n    },\n    computed: {\n        filled() {\n            return this.modelValue != null && this.modelValue.toString().length > 0;\n        },\n        inputClass() {\n            return [this.cx('root'), this.class];\n        },\n        ptmParams() {\n            return {\n                context: {\n                    filled: this.filled\n                }\n            };\n        }\n    },\n    components: {\n        InputText\n    }\n};\n</script>\n", "<template>\n    <InputText\n        :value=\"modelValue\"\n        :class=\"inputClass\"\n        :readonly=\"readonly\"\n        :disabled=\"disabled\"\n        :invalid=\"invalid\"\n        :variant=\"variant\"\n        :placeholder=\"placeholder\"\n        :fluid=\"fluid\"\n        :unstyled=\"unstyled\"\n        @input=\"onInput\"\n        @focus=\"onFocus\"\n        @blur=\"onBlur\"\n        @keydown=\"onKeyDown\"\n        @keypress=\"onKeyPress\"\n        @paste=\"onPaste\"\n        :pt=\"ptmi('root', ptmParams)\"\n    />\n</template>\n\n<script>\nimport { getUserAgent } from '@primeuix/utils/dom';\nimport InputText from 'primevue/inputtext';\nimport BaseInputMask from './BaseInputMask.vue';\n\nexport default {\n    name: 'InputMask',\n    extends: BaseInputMask,\n    inheritAttrs: false,\n    emits: ['update:modelValue', 'focus', 'blur', 'keydown', 'complete', 'keypress', 'paste'],\n    watch: {\n        mask(newMask, oldMask) {\n            if (oldMask !== newMask) {\n                this.initMask();\n            }\n        }\n    },\n    mounted() {\n        this.initMask();\n    },\n    updated() {\n        if (this.isValueUpdated()) {\n            this.updateValue();\n        }\n    },\n    methods: {\n        onInput(event) {\n            if (this.androidChrome) this.handleAndroidInput(event);\n            else this.handleInputChange(event);\n\n            this.$emit('update:modelValue', event.target.value);\n        },\n        onFocus(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            this.focus = true;\n\n            clearTimeout(this.caretTimeoutId);\n            let pos;\n\n            this.focusText = this.$el.value;\n\n            pos = this.checkVal();\n\n            this.caretTimeoutId = setTimeout(() => {\n                if (this.$el !== document.activeElement) {\n                    return;\n                }\n\n                this.writeBuffer();\n\n                if (pos === this.mask.replace('?', '').length) {\n                    this.caret(0, pos);\n                } else {\n                    this.caret(pos);\n                }\n            }, 10);\n\n            this.$emit('focus', event);\n        },\n        onBlur(event) {\n            this.focus = false;\n            this.checkVal();\n            this.updateModel(event);\n\n            if (this.$el.value !== this.focusText) {\n                let e = document.createEvent('HTMLEvents');\n\n                e.initEvent('change', true, false);\n                this.$el.dispatchEvent(e);\n            }\n\n            this.$emit('blur', event);\n        },\n        onKeyDown(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            let k = event.code,\n                pos,\n                begin,\n                end;\n            let iPhone = /iphone/i.test(getUserAgent());\n\n            this.oldVal = this.$el.value;\n\n            //backspace, delete, and escape get special treatment\n            if (k === 'Backspace' || k === 'Delete' || (iPhone && k === 'Escape')) {\n                pos = this.caret();\n                begin = pos.begin;\n                end = pos.end;\n\n                if (end - begin === 0) {\n                    begin = k !== 'Delete' ? this.seekPrev(begin) : (end = this.seekNext(begin - 1));\n                    end = k === 'Delete' ? this.seekNext(end) : end;\n                }\n\n                this.clearBuffer(begin, end);\n                this.shiftL(begin, end - 1);\n                this.updateModel(event);\n\n                event.preventDefault();\n            } else if (k === 'Enter') {\n                // enter\n                this.$el.blur();\n                this.updateModel(event);\n            } else if (k === 'Escape') {\n                // escape\n                this.$el.value = this.focusText;\n                this.caret(0, this.checkVal());\n                this.updateModel(event);\n                event.preventDefault();\n            }\n\n            this.$emit('keydown', event);\n        },\n        onKeyPress(event) {\n            if (this.readonly) {\n                return;\n            }\n\n            var k = event.code,\n                pos = this.caret(),\n                p,\n                c,\n                next,\n                completed;\n\n            if (event.ctrlKey || event.altKey || event.metaKey || event.shiftKey || event.key === 'CapsLock' || event.key === 'Escape' || event.key === 'Tab') {\n                //Ignore\n                return;\n            } else if (k && k !== 'Enter') {\n                if (pos.end - pos.begin !== 0) {\n                    this.clearBuffer(pos.begin, pos.end);\n                    this.shiftL(pos.begin, pos.end - 1);\n                }\n\n                p = this.seekNext(pos.begin - 1);\n\n                if (p < this.len) {\n                    c = event.key;\n\n                    if (this.tests[p].test(c)) {\n                        this.shiftR(p);\n\n                        this.buffer[p] = c;\n                        this.writeBuffer();\n                        next = this.seekNext(p);\n\n                        if (/android/i.test(getUserAgent())) {\n                            //Path for CSP Violation on FireFox OS 1.1\n                            let proxy = () => {\n                                this.caret(next);\n                            };\n\n                            setTimeout(proxy, 0);\n                        } else {\n                            this.caret(next);\n                        }\n\n                        if (pos.begin <= this.lastRequiredNonMaskPos) {\n                            completed = this.isCompleted();\n                        }\n                    }\n                }\n\n                event.preventDefault();\n            }\n\n            this.updateModel(event);\n\n            if (completed) {\n                this.$emit('complete', event);\n            }\n\n            this.$emit('keypress', event);\n        },\n        onPaste(event) {\n            this.handleInputChange(event);\n\n            this.$emit('paste', event);\n        },\n        caret(first, last) {\n            let range, begin, end;\n\n            if (!this.$el.offsetParent || this.$el !== document.activeElement) {\n                return;\n            }\n\n            if (typeof first === 'number') {\n                begin = first;\n                end = typeof last === 'number' ? last : begin;\n\n                if (this.$el.setSelectionRange) {\n                    this.$el.setSelectionRange(begin, end);\n                } else if (this.$el['createTextRange']) {\n                    range = this.$el['createTextRange']();\n                    range.collapse(true);\n                    range.moveEnd('character', end);\n                    range.moveStart('character', begin);\n                    range.select();\n                }\n            } else {\n                if (this.$el.setSelectionRange) {\n                    begin = this.$el.selectionStart;\n                    end = this.$el.selectionEnd;\n                } else if (document['selection'] && document['selection'].createRange) {\n                    range = document['selection'].createRange();\n                    begin = 0 - range.duplicate().moveStart('character', -100000);\n                    end = begin + range.text.length;\n                }\n\n                return { begin: begin, end: end };\n            }\n        },\n        isCompleted() {\n            for (let i = this.firstNonMaskPos; i <= this.lastRequiredNonMaskPos; i++) {\n                if (this.tests[i] && this.buffer[i] === this.getPlaceholder(i)) {\n                    return false;\n                }\n            }\n\n            return true;\n        },\n        getPlaceholder(i) {\n            if (i < this.slotChar.length) {\n                return this.slotChar.charAt(i);\n            }\n\n            return this.slotChar.charAt(0);\n        },\n        seekNext(pos) {\n            while (++pos < this.len && !this.tests[pos]);\n\n            return pos;\n        },\n        seekPrev(pos) {\n            while (--pos >= 0 && !this.tests[pos]);\n\n            return pos;\n        },\n        shiftL(begin, end) {\n            let i, j;\n\n            if (begin < 0) {\n                return;\n            }\n\n            for (i = begin, j = this.seekNext(end); i < this.len; i++) {\n                if (this.tests[i]) {\n                    if (j < this.len && this.tests[i].test(this.buffer[j])) {\n                        this.buffer[i] = this.buffer[j];\n                        this.buffer[j] = this.getPlaceholder(j);\n                    } else {\n                        break;\n                    }\n\n                    j = this.seekNext(j);\n                }\n            }\n\n            this.writeBuffer();\n            this.caret(Math.max(this.firstNonMaskPos, begin));\n        },\n        shiftR(pos) {\n            let i, c, j, t;\n\n            for (i = pos, c = this.getPlaceholder(pos); i < this.len; i++) {\n                if (this.tests[i]) {\n                    j = this.seekNext(i);\n                    t = this.buffer[i];\n                    this.buffer[i] = c;\n\n                    if (j < this.len && this.tests[j].test(t)) {\n                        c = t;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        },\n        handleAndroidInput(event) {\n            var curVal = this.$el.value;\n            var pos = this.caret();\n\n            if (this.oldVal && this.oldVal.length && this.oldVal.length > curVal.length) {\n                // a deletion or backspace happened\n                this.checkVal(true);\n                while (pos.begin > 0 && !this.tests[pos.begin - 1]) pos.begin--;\n\n                if (pos.begin === 0) {\n                    while (pos.begin < this.firstNonMaskPos && !this.tests[pos.begin]) pos.begin++;\n                }\n\n                this.caret(pos.begin, pos.begin);\n            } else {\n                this.checkVal(true);\n                while (pos.begin < this.len && !this.tests[pos.begin]) pos.begin++;\n\n                this.caret(pos.begin, pos.begin);\n            }\n\n            if (this.isCompleted()) {\n                this.$emit('complete', event);\n            }\n        },\n        clearBuffer(start, end) {\n            let i;\n\n            for (i = start; i < end && i < this.len; i++) {\n                if (this.tests[i]) {\n                    this.buffer[i] = this.getPlaceholder(i);\n                }\n            }\n        },\n        writeBuffer() {\n            this.$el.value = this.buffer.join('');\n        },\n        checkVal(allow) {\n            this.isValueChecked = true;\n            //try to place characters where they belong\n            let test = this.$el.value,\n                lastMatch = -1,\n                i,\n                c,\n                pos;\n\n            for (i = 0, pos = 0; i < this.len; i++) {\n                if (this.tests[i]) {\n                    this.buffer[i] = this.getPlaceholder(i);\n\n                    while (pos++ < test.length) {\n                        c = test.charAt(pos - 1);\n\n                        if (this.tests[i].test(c)) {\n                            this.buffer[i] = c;\n                            lastMatch = i;\n                            break;\n                        }\n                    }\n\n                    if (pos > test.length) {\n                        this.clearBuffer(i + 1, this.len);\n                        break;\n                    }\n                } else {\n                    if (this.buffer[i] === test.charAt(pos)) {\n                        pos++;\n                    }\n\n                    if (i < this.partialPosition) {\n                        lastMatch = i;\n                    }\n                }\n            }\n\n            if (allow) {\n                this.writeBuffer();\n            } else if (lastMatch + 1 < this.partialPosition) {\n                if (this.autoClear || this.buffer.join('') === this.defaultBuffer) {\n                    // Invalid value. Remove it and replace it with the\n                    // mask, which is the default behavior.\n                    if (this.$el.value) this.$el.value = '';\n                    this.clearBuffer(0, this.len);\n                } else {\n                    // Invalid value, but we opt to show the value to the\n                    // user and allow them to correct their mistake.\n                    this.writeBuffer();\n                }\n            } else {\n                this.writeBuffer();\n                this.$el.value = this.$el.value.substring(0, lastMatch + 1);\n            }\n\n            return this.partialPosition ? i : this.firstNonMaskPos;\n        },\n        handleInputChange(event) {\n            const isPasteEvent = event.type === 'paste';\n\n            if (this.readonly || isPasteEvent) {\n                return;\n            }\n\n            var pos = this.checkVal(true);\n\n            this.caret(pos);\n            this.updateModel(event);\n\n            if (this.isCompleted()) {\n                this.$emit('complete', event);\n            }\n        },\n        getUnmaskedValue() {\n            let unmaskedBuffer = [];\n\n            for (let i = 0; i < this.buffer.length; i++) {\n                let c = this.buffer[i];\n\n                if (this.tests[i] && c !== this.getPlaceholder(i)) {\n                    unmaskedBuffer.push(c);\n                }\n            }\n\n            return unmaskedBuffer.join('');\n        },\n        updateModel(e) {\n            let val = this.unmask ? this.getUnmaskedValue() : e.target.value;\n\n            this.$emit('update:modelValue', this.defaultBuffer !== val ? val : '');\n        },\n        updateValue(updateModel = true) {\n            if (this.$el) {\n                if (this.modelValue == null) {\n                    this.$el.value = '';\n                    updateModel && this.$emit('update:modelValue', '');\n                } else {\n                    this.$el.value = this.modelValue;\n                    this.checkVal();\n\n                    setTimeout(() => {\n                        if (this.$el) {\n                            this.writeBuffer();\n                            this.checkVal();\n\n                            if (updateModel) {\n                                let val = this.unmask ? this.getUnmaskedValue() : this.$el.value;\n\n                                this.$emit('update:modelValue', this.defaultBuffer !== val ? val : '');\n                            }\n                        }\n                    }, 10);\n                }\n\n                this.focusText = this.$el.value;\n            }\n        },\n        initMask() {\n            this.tests = [];\n            this.partialPosition = this.mask.length;\n            this.len = this.mask.length;\n            this.firstNonMaskPos = null;\n            this.defs = {\n                9: '[0-9]',\n                a: '[A-Za-z]',\n                '*': '[A-Za-z0-9]'\n            };\n\n            let ua = getUserAgent();\n\n            this.androidChrome = /chrome/i.test(ua) && /android/i.test(ua);\n\n            let maskTokens = this.mask.split('');\n\n            for (let i = 0; i < maskTokens.length; i++) {\n                let c = maskTokens[i];\n\n                if (c === '?') {\n                    this.len--;\n                    this.partialPosition = i;\n                } else if (this.defs[c]) {\n                    this.tests.push(new RegExp(this.defs[c]));\n\n                    if (this.firstNonMaskPos === null) {\n                        this.firstNonMaskPos = this.tests.length - 1;\n                    }\n\n                    if (i < this.partialPosition) {\n                        this.lastRequiredNonMaskPos = this.tests.length - 1;\n                    }\n                } else {\n                    this.tests.push(null);\n                }\n            }\n\n            this.buffer = [];\n\n            for (let i = 0; i < maskTokens.length; i++) {\n                let c = maskTokens[i];\n\n                if (c !== '?') {\n                    if (this.defs[c]) this.buffer.push(this.getPlaceholder(i));\n                    else this.buffer.push(c);\n                }\n            }\n\n            this.defaultBuffer = this.buffer.join('');\n            this.updateValue(false);\n        },\n        isValueUpdated() {\n            return this.unmask ? this.modelValue != this.getUnmaskedValue() : this.defaultBuffer !== this.$el.value && this.$el.value !== this.modelValue;\n        }\n    },\n    computed: {\n        filled() {\n            return this.modelValue != null && this.modelValue.toString().length > 0;\n        },\n        inputClass() {\n            return [this.cx('root'), this.class];\n        },\n        ptmParams() {\n            return {\n                context: {\n                    filled: this.filled\n                }\n            };\n        }\n    },\n    components: {\n        InputText\n    }\n};\n</script>\n"],
  "mappings": "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",
  "names": ["classes", "root", "_ref", "instance", "filled", "BaseStyle", "extend", "name", "name", "BaseComponent", "props", "modelValue", "slotChar", "type", "String", "Object", "mask", "placeholder", "autoClear", "Boolean", "unmask", "readonly", "invalid", "disabled", "variant", "fluid", "style", "InputMaskStyle", "provide", "$pcInputMask", "$parentInstance", "script", "BaseInputMask", "inheritAttrs", "emits", "watch", "newMask", "oldMask", "initMask", "mounted", "updated", "isValueUpdated", "updateValue", "methods", "onInput", "event", "androidChrome", "handleAndroidInput", "handleInputChange", "$emit", "target", "value", "onFocus", "_this", "focus", "clearTimeout", "caretTimeoutId", "pos", "focusText", "$el", "checkVal", "setTimeout", "document", "activeElement", "writeBuffer", "replace", "length", "caret", "onBlur", "updateModel", "e", "createEvent", "initEvent", "dispatchEvent", "onKeyDown", "k", "code", "begin", "end", "iPhone", "test", "getUserAgent", "oldVal", "seekPrev", "seekNext", "clearBuffer", "shiftL", "preventDefault", "blur", "onKeyPress", "_this2", "p", "c", "next", "completed", "ctrlKey", "altKey", "metaKey", "shiftKey", "key", "len", "tests", "shiftR", "buffer", "proxy", "lastRequiredNonMaskPos", "isCompleted", "onPaste", "first", "last", "range", "offsetParent", "setSelectionRange", "collapse", "moveEnd", "moveStart", "select", "selectionStart", "selectionEnd", "createRange", "duplicate", "text", "i", "firstNonMaskPos", "getPlaceholder", "charAt", "j", "Math", "max", "t", "curVal", "start", "join", "allow", "isValueChecked", "lastMatch", "partialPosition", "defaultBuffer", "substring", "isPasteEvent", "getUnmaskedValue", "unmaskedBuffer", "push", "val", "_this3", "arguments", "undefined", "defs", "a", "ua", "maskTokens", "split", "RegExp", "computed", "filled", "toString", "inputClass", "cx", "ptmParams", "context", "components", "InputText", "_createBlock", "_component_InputText", "_ctx", "$options", "unstyled", "onKeydown", "onKeypress", "pt", "ptmi"]
}
