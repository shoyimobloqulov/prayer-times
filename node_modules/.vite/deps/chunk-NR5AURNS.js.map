{
  "version": 3,
  "sources": ["../../src/virtualscroller/style/VirtualScrollerStyle.js", "../../src/virtualscroller/BaseVirtualScroller.vue", "../../src/virtualscroller/VirtualScroller.vue", "../../src/virtualscroller/VirtualScroller.vue?vue&type=template&id=81b1e8fe&lang.js"],
  "sourcesContent": ["import BaseStyle from '@primevue/core/base/style';\n\nconst theme = ({ dt }) => `\n.p-virtualscroller {\n    position: relative;\n    overflow: auto;\n    contain: strict;\n    transform: translateZ(0);\n    will-change: scroll-position;\n    outline: 0 none;\n}\n\n.p-virtualscroller-content {\n    position: absolute;\n    top: 0;\n    left: 0;\n    min-height: 100%;\n    min-width: 100%;\n    will-change: transform;\n}\n\n.p-virtualscroller-spacer {\n    position: absolute;\n    top: 0;\n    left: 0;\n    height: 1px;\n    width: 1px;\n    transform-origin: 0 0;\n    pointer-events: none;\n}\n\n.p-virtualscroller-loader {\n    position: sticky;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background: ${dt('virtualscroller.loader.mask.background')};\n    color: ${dt('virtualscroller.loader.mask.color')};\n}\n\n.p-virtualscroller-loader-mask {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.p-virtualscroller-loading-icon {\n    font-size: ${dt('virtualscroller.loader.icon.size')};\n    width: ${dt('virtualscroller.loader.icon.size')};\n    height: ${dt('virtualscroller.loader.icon.size')};\n}\n\n.p-virtualscroller-horizontal > .p-virtualscroller-content {\n    display: flex;\n}\n\n.p-virtualscroller-inline .p-virtualscroller-content {\n    position: static;\n}\n`;\n\nexport default BaseStyle.extend({\n    name: 'virtualscroller',\n    theme\n});\n", "<script>\nimport BaseComponent from '@primevue/core/basecomponent';\nimport VirtualScrollerStyle from 'primevue/virtualscroller/style';\n\nexport default {\n    name: 'BaseVirtualScroller',\n    extends: BaseComponent,\n    props: {\n        id: {\n            type: String,\n            default: null\n        },\n        style: null,\n        class: null,\n        items: {\n            type: Array,\n            default: null\n        },\n        itemSize: {\n            type: [Number, Array],\n            default: 0\n        },\n        scrollHeight: null,\n        scrollWidth: null,\n        orientation: {\n            type: String,\n            default: 'vertical'\n        },\n        numToleratedItems: {\n            type: Number,\n            default: null\n        },\n        delay: {\n            type: Number,\n            default: 0\n        },\n        resizeDelay: {\n            type: Number,\n            default: 10\n        },\n        lazy: {\n            type: Boolean,\n            default: false\n        },\n        disabled: {\n            type: Boolean,\n            default: false\n        },\n        loaderDisabled: {\n            type: Boolean,\n            default: false\n        },\n        columns: {\n            type: Array,\n            default: null\n        },\n        loading: {\n            type: Boolean,\n            default: false\n        },\n        showSpacer: {\n            type: Boolean,\n            default: true\n        },\n        showLoader: {\n            type: Boolean,\n            default: false\n        },\n        tabindex: {\n            type: Number,\n            default: 0\n        },\n        inline: {\n            type: Boolean,\n            default: false\n        },\n        step: {\n            type: Number,\n            default: 0\n        },\n        appendOnly: {\n            type: Boolean,\n            default: false\n        },\n        autoSize: {\n            type: Boolean,\n            default: false\n        }\n    },\n    style: VirtualScrollerStyle,\n    provide() {\n        return {\n            $pcVirtualScroller: this,\n            $parentInstance: this\n        };\n    },\n    beforeMount() {\n        VirtualScrollerStyle.loadCSS({ nonce: this.$primevueConfig?.csp?.nonce });\n    }\n};\n</script>\n", "<template>\n    <template v-if=\"!disabled\">\n        <div :ref=\"elementRef\" :class=\"containerClass\" :tabindex=\"tabindex\" :style=\"style\" @scroll=\"onScroll\" v-bind=\"ptmi('root')\">\n            <slot\n                name=\"content\"\n                :styleClass=\"contentClass\"\n                :items=\"loadedItems\"\n                :getItemOptions=\"getOptions\"\n                :loading=\"d_loading\"\n                :getLoaderOptions=\"getLoaderOptions\"\n                :itemSize=\"itemSize\"\n                :rows=\"loadedRows\"\n                :columns=\"loadedColumns\"\n                :contentRef=\"contentRef\"\n                :spacerStyle=\"spacerStyle\"\n                :contentStyle=\"contentStyle\"\n                :vertical=\"isVertical()\"\n                :horizontal=\"isHorizontal()\"\n                :both=\"isBoth()\"\n            >\n                <div :ref=\"contentRef\" :class=\"contentClass\" :style=\"contentStyle\" v-bind=\"ptm('content')\">\n                    <template v-for=\"(item, index) of loadedItems\" :key=\"index\">\n                        <slot name=\"item\" :item=\"item\" :options=\"getOptions(index)\"></slot>\n                    </template>\n                </div>\n            </slot>\n            <div v-if=\"showSpacer\" class=\"p-virtualscroller-spacer\" :style=\"spacerStyle\" v-bind=\"ptm('spacer')\"></div>\n            <div v-if=\"!loaderDisabled && showLoader && d_loading\" :class=\"loaderClass\" v-bind=\"ptm('loader')\">\n                <template v-if=\"$slots && $slots.loader\">\n                    <template v-for=\"(_, index) of loaderArr\" :key=\"index\">\n                        <slot name=\"loader\" :options=\"getLoaderOptions(index, isBoth() && { numCols: d_numItemsInViewport.cols })\"></slot>\n                    </template>\n                </template>\n                <slot name=\"loadingicon\">\n                    <SpinnerIcon spin class=\"p-virtualscroller-loading-icon\" v-bind=\"ptm('loadingIcon')\" />\n                </slot>\n            </div>\n        </div>\n    </template>\n    <template v-else>\n        <slot></slot>\n        <slot name=\"content\" :items=\"items\" :rows=\"items\" :columns=\"loadedColumns\"></slot>\n    </template>\n</template>\n\n<script>\nimport { findSingle, getHeight, getWidth, isVisible } from '@primeuix/utils/dom';\nimport SpinnerIcon from '@primevue/icons/spinner';\nimport BaseVirtualScroller from './BaseVirtualScroller.vue';\n\nexport default {\n    name: 'VirtualScroller',\n    extends: BaseVirtualScroller,\n    inheritAttrs: false,\n    emits: ['update:numToleratedItems', 'scroll', 'scroll-index-change', 'lazy-load'],\n    data() {\n        const both = this.isBoth();\n\n        return {\n            first: both ? { rows: 0, cols: 0 } : 0,\n            last: both ? { rows: 0, cols: 0 } : 0,\n            page: both ? { rows: 0, cols: 0 } : 0,\n            numItemsInViewport: both ? { rows: 0, cols: 0 } : 0,\n            lastScrollPos: both ? { top: 0, left: 0 } : 0,\n            d_numToleratedItems: this.numToleratedItems,\n            d_loading: this.loading,\n            loaderArr: [],\n            spacerStyle: {},\n            contentStyle: {}\n        };\n    },\n    element: null,\n    content: null,\n    lastScrollPos: null,\n    scrollTimeout: null,\n    resizeTimeout: null,\n    defaultWidth: 0,\n    defaultHeight: 0,\n    defaultContentWidth: 0,\n    defaultContentHeight: 0,\n    isRangeChanged: false,\n    lazyLoadState: {},\n    resizeListener: null,\n    initialized: false,\n    watch: {\n        numToleratedItems(newValue) {\n            this.d_numToleratedItems = newValue;\n        },\n        loading(newValue, oldValue) {\n            if (this.lazy && newValue !== oldValue && newValue !== this.d_loading) {\n                this.d_loading = newValue;\n            }\n        },\n        items(newValue, oldValue) {\n            if (!oldValue || oldValue.length !== (newValue || []).length) {\n                this.init();\n                this.calculateAutoSize();\n            }\n        },\n        itemSize() {\n            this.init();\n            this.calculateAutoSize();\n        },\n        orientation() {\n            this.lastScrollPos = this.isBoth() ? { top: 0, left: 0 } : 0;\n        },\n        scrollHeight() {\n            this.init();\n            this.calculateAutoSize();\n        },\n        scrollWidth() {\n            this.init();\n            this.calculateAutoSize();\n        }\n    },\n    mounted() {\n        this.viewInit();\n\n        this.lastScrollPos = this.isBoth() ? { top: 0, left: 0 } : 0;\n        this.lazyLoadState = this.lazyLoadState || {};\n    },\n    updated() {\n        !this.initialized && this.viewInit();\n    },\n    unmounted() {\n        this.unbindResizeListener();\n\n        this.initialized = false;\n    },\n    methods: {\n        viewInit() {\n            if (isVisible(this.element)) {\n                this.setContentEl(this.content);\n                this.init();\n                this.calculateAutoSize();\n                this.bindResizeListener();\n\n                this.defaultWidth = getWidth(this.element);\n                this.defaultHeight = getHeight(this.element);\n                this.defaultContentWidth = getWidth(this.content);\n                this.defaultContentHeight = getHeight(this.content);\n                this.initialized = true;\n            }\n        },\n        init() {\n            if (!this.disabled) {\n                this.setSize();\n                this.calculateOptions();\n                this.setSpacerSize();\n            }\n        },\n        isVertical() {\n            return this.orientation === 'vertical';\n        },\n        isHorizontal() {\n            return this.orientation === 'horizontal';\n        },\n        isBoth() {\n            return this.orientation === 'both';\n        },\n        scrollTo(options) {\n            //this.lastScrollPos = this.both ? { top: 0, left: 0 } : 0;\n            this.element && this.element.scrollTo(options);\n        },\n        scrollToIndex(index, behavior = 'auto') {\n            const both = this.isBoth();\n            const horizontal = this.isHorizontal();\n            const valid = both ? index.every((i) => i > -1) : index > -1;\n\n            if (valid) {\n                const first = this.first;\n                const { scrollTop = 0, scrollLeft = 0 } = this.element;\n                const { numToleratedItems } = this.calculateNumItems();\n                const contentPos = this.getContentPosition();\n                const itemSize = this.itemSize;\n                const calculateFirst = (_index = 0, _numT) => (_index <= _numT ? 0 : _index);\n                const calculateCoord = (_first, _size, _cpos) => _first * _size + _cpos;\n                const scrollTo = (left = 0, top = 0) => this.scrollTo({ left, top, behavior });\n                let newFirst = both ? { rows: 0, cols: 0 } : 0;\n                let isRangeChanged = false,\n                    isScrollChanged = false;\n\n                if (both) {\n                    newFirst = { rows: calculateFirst(index[0], numToleratedItems[0]), cols: calculateFirst(index[1], numToleratedItems[1]) };\n                    scrollTo(calculateCoord(newFirst.cols, itemSize[1], contentPos.left), calculateCoord(newFirst.rows, itemSize[0], contentPos.top));\n                    isScrollChanged = this.lastScrollPos.top !== scrollTop || this.lastScrollPos.left !== scrollLeft;\n                    isRangeChanged = newFirst.rows !== first.rows || newFirst.cols !== first.cols;\n                } else {\n                    newFirst = calculateFirst(index, numToleratedItems);\n                    horizontal ? scrollTo(calculateCoord(newFirst, itemSize, contentPos.left), scrollTop) : scrollTo(scrollLeft, calculateCoord(newFirst, itemSize, contentPos.top));\n                    isScrollChanged = this.lastScrollPos !== (horizontal ? scrollLeft : scrollTop);\n                    isRangeChanged = newFirst !== first;\n                }\n\n                this.isRangeChanged = isRangeChanged;\n                isScrollChanged && (this.first = newFirst);\n            }\n        },\n        scrollInView(index, to, behavior = 'auto') {\n            if (to) {\n                const both = this.isBoth();\n                const horizontal = this.isHorizontal();\n                const valid = both ? index.every((i) => i > -1) : index > -1;\n\n                if (valid) {\n                    const { first, viewport } = this.getRenderedRange();\n                    const scrollTo = (left = 0, top = 0) => this.scrollTo({ left, top, behavior });\n                    const isToStart = to === 'to-start';\n                    const isToEnd = to === 'to-end';\n\n                    if (isToStart) {\n                        if (both) {\n                            if (viewport.first.rows - first.rows > index[0]) {\n                                scrollTo(viewport.first.cols * this.itemSize[1], (viewport.first.rows - 1) * this.itemSize[0]);\n                            } else if (viewport.first.cols - first.cols > index[1]) {\n                                scrollTo((viewport.first.cols - 1) * this.itemSize[1], viewport.first.rows * this.itemSize[0]);\n                            }\n                        } else {\n                            if (viewport.first - first > index) {\n                                const pos = (viewport.first - 1) * this.itemSize;\n\n                                horizontal ? scrollTo(pos, 0) : scrollTo(0, pos);\n                            }\n                        }\n                    } else if (isToEnd) {\n                        if (both) {\n                            if (viewport.last.rows - first.rows <= index[0] + 1) {\n                                scrollTo(viewport.first.cols * this.itemSize[1], (viewport.first.rows + 1) * this.itemSize[0]);\n                            } else if (viewport.last.cols - first.cols <= index[1] + 1) {\n                                scrollTo((viewport.first.cols + 1) * this.itemSize[1], viewport.first.rows * this.itemSize[0]);\n                            }\n                        } else {\n                            if (viewport.last - first <= index + 1) {\n                                const pos = (viewport.first + 1) * this.itemSize;\n\n                                horizontal ? scrollTo(pos, 0) : scrollTo(0, pos);\n                            }\n                        }\n                    }\n                }\n            } else {\n                this.scrollToIndex(index, behavior);\n            }\n        },\n        getRenderedRange() {\n            const calculateFirstInViewport = (_pos, _size) => Math.floor(_pos / (_size || _pos));\n\n            let firstInViewport = this.first;\n            let lastInViewport = 0;\n\n            if (this.element) {\n                const both = this.isBoth();\n                const horizontal = this.isHorizontal();\n                const { scrollTop, scrollLeft } = this.element;\n\n                if (both) {\n                    firstInViewport = { rows: calculateFirstInViewport(scrollTop, this.itemSize[0]), cols: calculateFirstInViewport(scrollLeft, this.itemSize[1]) };\n                    lastInViewport = { rows: firstInViewport.rows + this.numItemsInViewport.rows, cols: firstInViewport.cols + this.numItemsInViewport.cols };\n                } else {\n                    const scrollPos = horizontal ? scrollLeft : scrollTop;\n\n                    firstInViewport = calculateFirstInViewport(scrollPos, this.itemSize);\n                    lastInViewport = firstInViewport + this.numItemsInViewport;\n                }\n            }\n\n            return {\n                first: this.first,\n                last: this.last,\n                viewport: {\n                    first: firstInViewport,\n                    last: lastInViewport\n                }\n            };\n        },\n        calculateNumItems() {\n            const both = this.isBoth();\n            const horizontal = this.isHorizontal();\n            const itemSize = this.itemSize;\n            const contentPos = this.getContentPosition();\n            const contentWidth = this.element ? this.element.offsetWidth - contentPos.left : 0;\n            const contentHeight = this.element ? this.element.offsetHeight - contentPos.top : 0;\n            const calculateNumItemsInViewport = (_contentSize, _itemSize) => Math.ceil(_contentSize / (_itemSize || _contentSize));\n            const calculateNumToleratedItems = (_numItems) => Math.ceil(_numItems / 2);\n            const numItemsInViewport = both\n                ? { rows: calculateNumItemsInViewport(contentHeight, itemSize[0]), cols: calculateNumItemsInViewport(contentWidth, itemSize[1]) }\n                : calculateNumItemsInViewport(horizontal ? contentWidth : contentHeight, itemSize);\n\n            const numToleratedItems = this.d_numToleratedItems || (both ? [calculateNumToleratedItems(numItemsInViewport.rows), calculateNumToleratedItems(numItemsInViewport.cols)] : calculateNumToleratedItems(numItemsInViewport));\n\n            return { numItemsInViewport, numToleratedItems };\n        },\n        calculateOptions() {\n            const both = this.isBoth();\n            const first = this.first;\n            const { numItemsInViewport, numToleratedItems } = this.calculateNumItems();\n            const calculateLast = (_first, _num, _numT, _isCols = false) => this.getLast(_first + _num + (_first < _numT ? 2 : 3) * _numT, _isCols);\n            const last = both\n                ? { rows: calculateLast(first.rows, numItemsInViewport.rows, numToleratedItems[0]), cols: calculateLast(first.cols, numItemsInViewport.cols, numToleratedItems[1], true) }\n                : calculateLast(first, numItemsInViewport, numToleratedItems);\n\n            this.last = last;\n            this.numItemsInViewport = numItemsInViewport;\n            this.d_numToleratedItems = numToleratedItems;\n            this.$emit('update:numToleratedItems', this.d_numToleratedItems);\n\n            if (this.showLoader) {\n                this.loaderArr = both ? Array.from({ length: numItemsInViewport.rows }).map(() => Array.from({ length: numItemsInViewport.cols })) : Array.from({ length: numItemsInViewport });\n            }\n\n            if (this.lazy) {\n                Promise.resolve().then(() => {\n                    this.lazyLoadState = {\n                        first: this.step ? (both ? { rows: 0, cols: first.cols } : 0) : first,\n                        last: Math.min(this.step ? this.step : last, this.items?.length || 0)\n                    };\n\n                    this.$emit('lazy-load', this.lazyLoadState);\n                });\n            }\n        },\n        calculateAutoSize() {\n            if (this.autoSize && !this.d_loading) {\n                Promise.resolve().then(() => {\n                    if (this.content) {\n                        const both = this.isBoth();\n                        const horizontal = this.isHorizontal();\n                        const vertical = this.isVertical();\n\n                        this.content.style.minHeight = this.content.style.minWidth = 'auto';\n                        this.content.style.position = 'relative';\n                        this.element.style.contain = 'none';\n\n                        /*const [contentWidth, contentHeight] = [getWidth(this.content), getHeight(this.content)];\n\n                        contentWidth !== this.defaultContentWidth && (this.element.style.width = '');\n                        contentHeight !== this.defaultContentHeight && (this.element.style.height = '');*/\n\n                        const [width, height] = [getWidth(this.element), getHeight(this.element)];\n\n                        (both || horizontal) && (this.element.style.width = width < this.defaultWidth ? width + 'px' : this.scrollWidth || this.defaultWidth + 'px');\n                        (both || vertical) && (this.element.style.height = height < this.defaultHeight ? height + 'px' : this.scrollHeight || this.defaultHeight + 'px');\n\n                        this.content.style.minHeight = this.content.style.minWidth = '';\n                        this.content.style.position = '';\n                        this.element.style.contain = '';\n                    }\n                });\n            }\n        },\n        getLast(last = 0, isCols) {\n            return this.items ? Math.min(isCols ? (this.columns || this.items[0])?.length || 0 : this.items?.length || 0, last) : 0;\n        },\n        getContentPosition() {\n            if (this.content) {\n                const style = getComputedStyle(this.content);\n                const left = parseFloat(style.paddingLeft) + Math.max(parseFloat(style.left) || 0, 0);\n                const right = parseFloat(style.paddingRight) + Math.max(parseFloat(style.right) || 0, 0);\n                const top = parseFloat(style.paddingTop) + Math.max(parseFloat(style.top) || 0, 0);\n                const bottom = parseFloat(style.paddingBottom) + Math.max(parseFloat(style.bottom) || 0, 0);\n\n                return { left, right, top, bottom, x: left + right, y: top + bottom };\n            }\n\n            return { left: 0, right: 0, top: 0, bottom: 0, x: 0, y: 0 };\n        },\n        setSize() {\n            if (this.element) {\n                const both = this.isBoth();\n                const horizontal = this.isHorizontal();\n                const parentElement = this.element.parentElement;\n                const width = this.scrollWidth || `${this.element.offsetWidth || parentElement.offsetWidth}px`;\n                const height = this.scrollHeight || `${this.element.offsetHeight || parentElement.offsetHeight}px`;\n                const setProp = (_name, _value) => (this.element.style[_name] = _value);\n\n                if (both || horizontal) {\n                    setProp('height', height);\n                    setProp('width', width);\n                } else {\n                    setProp('height', height);\n                }\n            }\n        },\n        setSpacerSize() {\n            const items = this.items;\n\n            if (items) {\n                const both = this.isBoth();\n                const horizontal = this.isHorizontal();\n                const contentPos = this.getContentPosition();\n                const setProp = (_name, _value, _size, _cpos = 0) => (this.spacerStyle = { ...this.spacerStyle, ...{ [`${_name}`]: (_value || []).length * _size + _cpos + 'px' } });\n\n                if (both) {\n                    setProp('height', items, this.itemSize[0], contentPos.y);\n                    setProp('width', this.columns || items[1], this.itemSize[1], contentPos.x);\n                } else {\n                    horizontal ? setProp('width', this.columns || items, this.itemSize, contentPos.x) : setProp('height', items, this.itemSize, contentPos.y);\n                }\n            }\n        },\n        setContentPosition(pos) {\n            if (this.content && !this.appendOnly) {\n                const both = this.isBoth();\n                const horizontal = this.isHorizontal();\n                const first = pos ? pos.first : this.first;\n                const calculateTranslateVal = (_first, _size) => _first * _size;\n                const setTransform = (_x = 0, _y = 0) => (this.contentStyle = { ...this.contentStyle, ...{ transform: `translate3d(${_x}px, ${_y}px, 0)` } });\n\n                if (both) {\n                    setTransform(calculateTranslateVal(first.cols, this.itemSize[1]), calculateTranslateVal(first.rows, this.itemSize[0]));\n                } else {\n                    const translateVal = calculateTranslateVal(first, this.itemSize);\n\n                    horizontal ? setTransform(translateVal, 0) : setTransform(0, translateVal);\n                }\n            }\n        },\n        onScrollPositionChange(event) {\n            const target = event.target;\n            const both = this.isBoth();\n            const horizontal = this.isHorizontal();\n            const contentPos = this.getContentPosition();\n            const calculateScrollPos = (_pos, _cpos) => (_pos ? (_pos > _cpos ? _pos - _cpos : _pos) : 0);\n            const calculateCurrentIndex = (_pos, _size) => Math.floor(_pos / (_size || _pos));\n\n            const calculateTriggerIndex = (_currentIndex, _first, _last, _num, _numT, _isScrollDownOrRight) => {\n                return _currentIndex <= _numT ? _numT : _isScrollDownOrRight ? _last - _num - _numT : _first + _numT - 1;\n            };\n\n            const calculateFirst = (_currentIndex, _triggerIndex, _first, _last, _num, _numT, _isScrollDownOrRight) => {\n                if (_currentIndex <= _numT) return 0;\n                else return Math.max(0, _isScrollDownOrRight ? (_currentIndex < _triggerIndex ? _first : _currentIndex - _numT) : _currentIndex > _triggerIndex ? _first : _currentIndex - 2 * _numT);\n            };\n\n            const calculateLast = (_currentIndex, _first, _last, _num, _numT, _isCols) => {\n                let lastValue = _first + _num + 2 * _numT;\n\n                if (_currentIndex >= _numT) {\n                    lastValue += _numT + 1;\n                }\n\n                return this.getLast(lastValue, _isCols);\n            };\n\n            const scrollTop = calculateScrollPos(target.scrollTop, contentPos.top);\n            const scrollLeft = calculateScrollPos(target.scrollLeft, contentPos.left);\n\n            let newFirst = both ? { rows: 0, cols: 0 } : 0;\n            let newLast = this.last;\n            let isRangeChanged = false;\n            let newScrollPos = this.lastScrollPos;\n\n            if (both) {\n                const isScrollDown = this.lastScrollPos.top <= scrollTop;\n                const isScrollRight = this.lastScrollPos.left <= scrollLeft;\n\n                if (!this.appendOnly || (this.appendOnly && (isScrollDown || isScrollRight))) {\n                    const currentIndex = { rows: calculateCurrentIndex(scrollTop, this.itemSize[0]), cols: calculateCurrentIndex(scrollLeft, this.itemSize[1]) };\n                    const triggerIndex = {\n                        rows: calculateTriggerIndex(currentIndex.rows, this.first.rows, this.last.rows, this.numItemsInViewport.rows, this.d_numToleratedItems[0], isScrollDown),\n                        cols: calculateTriggerIndex(currentIndex.cols, this.first.cols, this.last.cols, this.numItemsInViewport.cols, this.d_numToleratedItems[1], isScrollRight)\n                    };\n\n                    newFirst = {\n                        rows: calculateFirst(currentIndex.rows, triggerIndex.rows, this.first.rows, this.last.rows, this.numItemsInViewport.rows, this.d_numToleratedItems[0], isScrollDown),\n                        cols: calculateFirst(currentIndex.cols, triggerIndex.cols, this.first.cols, this.last.cols, this.numItemsInViewport.cols, this.d_numToleratedItems[1], isScrollRight)\n                    };\n                    newLast = {\n                        rows: calculateLast(currentIndex.rows, newFirst.rows, this.last.rows, this.numItemsInViewport.rows, this.d_numToleratedItems[0]),\n                        cols: calculateLast(currentIndex.cols, newFirst.cols, this.last.cols, this.numItemsInViewport.cols, this.d_numToleratedItems[1], true)\n                    };\n\n                    isRangeChanged = newFirst.rows !== this.first.rows || newLast.rows !== this.last.rows || newFirst.cols !== this.first.cols || newLast.cols !== this.last.cols || this.isRangeChanged;\n                    newScrollPos = { top: scrollTop, left: scrollLeft };\n                }\n            } else {\n                const scrollPos = horizontal ? scrollLeft : scrollTop;\n                const isScrollDownOrRight = this.lastScrollPos <= scrollPos;\n\n                if (!this.appendOnly || (this.appendOnly && isScrollDownOrRight)) {\n                    const currentIndex = calculateCurrentIndex(scrollPos, this.itemSize);\n                    const triggerIndex = calculateTriggerIndex(currentIndex, this.first, this.last, this.numItemsInViewport, this.d_numToleratedItems, isScrollDownOrRight);\n\n                    newFirst = calculateFirst(currentIndex, triggerIndex, this.first, this.last, this.numItemsInViewport, this.d_numToleratedItems, isScrollDownOrRight);\n                    newLast = calculateLast(currentIndex, newFirst, this.last, this.numItemsInViewport, this.d_numToleratedItems);\n                    isRangeChanged = newFirst !== this.first || newLast !== this.last || this.isRangeChanged;\n                    newScrollPos = scrollPos;\n                }\n            }\n\n            return {\n                first: newFirst,\n                last: newLast,\n                isRangeChanged,\n                scrollPos: newScrollPos\n            };\n        },\n        onScrollChange(event) {\n            const { first, last, isRangeChanged, scrollPos } = this.onScrollPositionChange(event);\n\n            if (isRangeChanged) {\n                const newState = { first, last };\n\n                this.setContentPosition(newState);\n\n                this.first = first;\n                this.last = last;\n                this.lastScrollPos = scrollPos;\n\n                this.$emit('scroll-index-change', newState);\n\n                if (this.lazy && this.isPageChanged(first)) {\n                    const lazyLoadState = {\n                        first: this.step ? Math.min(this.getPageByFirst(first) * this.step, (this.items?.length || 0) - this.step) : first,\n                        last: Math.min(this.step ? (this.getPageByFirst(first) + 1) * this.step : last, this.items?.length || 0)\n                    };\n                    const isLazyStateChanged = this.lazyLoadState.first !== lazyLoadState.first || this.lazyLoadState.last !== lazyLoadState.last;\n\n                    isLazyStateChanged && this.$emit('lazy-load', lazyLoadState);\n                    this.lazyLoadState = lazyLoadState;\n                }\n            }\n        },\n        onScroll(event) {\n            this.$emit('scroll', event);\n\n            if (this.delay) {\n                if (this.scrollTimeout) {\n                    clearTimeout(this.scrollTimeout);\n                }\n\n                if (this.isPageChanged()) {\n                    if (!this.d_loading && this.showLoader) {\n                        const { isRangeChanged } = this.onScrollPositionChange(event);\n                        const changed = isRangeChanged || (this.step ? this.isPageChanged() : false);\n\n                        changed && (this.d_loading = true);\n                    }\n\n                    this.scrollTimeout = setTimeout(() => {\n                        this.onScrollChange(event);\n\n                        if (this.d_loading && this.showLoader && (!this.lazy || this.loading === undefined)) {\n                            this.d_loading = false;\n                            this.page = this.getPageByFirst();\n                        }\n                    }, this.delay);\n                }\n            } else {\n                this.onScrollChange(event);\n            }\n        },\n        onResize() {\n            if (this.resizeTimeout) {\n                clearTimeout(this.resizeTimeout);\n            }\n\n            this.resizeTimeout = setTimeout(() => {\n                if (isVisible(this.element)) {\n                    const both = this.isBoth();\n                    const vertical = this.isVertical();\n                    const horizontal = this.isHorizontal();\n                    const [width, height] = [getWidth(this.element), getHeight(this.element)];\n                    const [isDiffWidth, isDiffHeight] = [width !== this.defaultWidth, height !== this.defaultHeight];\n                    const reinit = both ? isDiffWidth || isDiffHeight : horizontal ? isDiffWidth : vertical ? isDiffHeight : false;\n\n                    if (reinit) {\n                        this.d_numToleratedItems = this.numToleratedItems;\n                        this.defaultWidth = width;\n                        this.defaultHeight = height;\n                        this.defaultContentWidth = getWidth(this.content);\n                        this.defaultContentHeight = getHeight(this.content);\n\n                        this.init();\n                    }\n                }\n            }, this.resizeDelay);\n        },\n        bindResizeListener() {\n            if (!this.resizeListener) {\n                this.resizeListener = this.onResize.bind(this);\n\n                window.addEventListener('resize', this.resizeListener);\n                window.addEventListener('orientationchange', this.resizeListener);\n            }\n        },\n        unbindResizeListener() {\n            if (this.resizeListener) {\n                window.removeEventListener('resize', this.resizeListener);\n                window.removeEventListener('orientationchange', this.resizeListener);\n                this.resizeListener = null;\n            }\n        },\n        getOptions(renderedIndex) {\n            const count = (this.items || []).length;\n            const index = this.isBoth() ? this.first.rows + renderedIndex : this.first + renderedIndex;\n\n            return {\n                index,\n                count,\n                first: index === 0,\n                last: index === count - 1,\n                even: index % 2 === 0,\n                odd: index % 2 !== 0\n            };\n        },\n        getLoaderOptions(index, extOptions) {\n            let count = this.loaderArr.length;\n\n            return {\n                index,\n                count,\n                first: index === 0,\n                last: index === count - 1,\n                even: index % 2 === 0,\n                odd: index % 2 !== 0,\n                ...extOptions\n            };\n        },\n        getPageByFirst(first) {\n            return Math.floor(((first ?? this.first) + this.d_numToleratedItems * 4) / (this.step || 1));\n        },\n        isPageChanged(first) {\n            return this.step ? this.page !== this.getPageByFirst(first ?? this.first) : true;\n        },\n        setContentEl(el) {\n            this.content = el || this.content || findSingle(this.element, '[data-pc-section=\"content\"]');\n        },\n        elementRef(el) {\n            this.element = el;\n        },\n        contentRef(el) {\n            this.content = el;\n        }\n    },\n    computed: {\n        containerClass() {\n            return [\n                'p-virtualscroller',\n                this.class,\n                {\n                    'p-virtualscroller-inline': this.inline,\n                    'p-virtualscroller-both p-both-scroll': this.isBoth(),\n                    'p-virtualscroller-horizontal p-horizontal-scroll': this.isHorizontal()\n                }\n            ];\n        },\n        contentClass() {\n            return [\n                'p-virtualscroller-content',\n                {\n                    'p-virtualscroller-loading': this.d_loading\n                }\n            ];\n        },\n        loaderClass() {\n            return [\n                'p-virtualscroller-loader',\n                {\n                    'p-virtualscroller-loader-mask': !this.$slots.loader\n                }\n            ];\n        },\n        loadedItems() {\n            if (this.items && !this.d_loading) {\n                if (this.isBoth()) return this.items.slice(this.appendOnly ? 0 : this.first.rows, this.last.rows).map((item) => (this.columns ? item : item.slice(this.appendOnly ? 0 : this.first.cols, this.last.cols)));\n                else if (this.isHorizontal() && this.columns) return this.items;\n                else return this.items.slice(this.appendOnly ? 0 : this.first, this.last);\n            }\n\n            return [];\n        },\n        loadedRows() {\n            return this.d_loading ? (this.loaderDisabled ? this.loaderArr : []) : this.loadedItems;\n        },\n        loadedColumns() {\n            if (this.columns) {\n                const both = this.isBoth();\n                const horizontal = this.isHorizontal();\n\n                if (both || horizontal) {\n                    return this.d_loading && this.loaderDisabled ? (both ? this.loaderArr[0] : this.loaderArr) : this.columns.slice(both ? this.first.cols : this.first, both ? this.last.cols : this.last);\n                }\n            }\n\n            return this.columns;\n        }\n    },\n    components: {\n        SpinnerIcon: SpinnerIcon\n    }\n};\n</script>\n", "<template>\n    <template v-if=\"!disabled\">\n        <div :ref=\"elementRef\" :class=\"containerClass\" :tabindex=\"tabindex\" :style=\"style\" @scroll=\"onScroll\" v-bind=\"ptmi('root')\">\n            <slot\n                name=\"content\"\n                :styleClass=\"contentClass\"\n                :items=\"loadedItems\"\n                :getItemOptions=\"getOptions\"\n                :loading=\"d_loading\"\n                :getLoaderOptions=\"getLoaderOptions\"\n                :itemSize=\"itemSize\"\n                :rows=\"loadedRows\"\n                :columns=\"loadedColumns\"\n                :contentRef=\"contentRef\"\n                :spacerStyle=\"spacerStyle\"\n                :contentStyle=\"contentStyle\"\n                :vertical=\"isVertical()\"\n                :horizontal=\"isHorizontal()\"\n                :both=\"isBoth()\"\n            >\n                <div :ref=\"contentRef\" :class=\"contentClass\" :style=\"contentStyle\" v-bind=\"ptm('content')\">\n                    <template v-for=\"(item, index) of loadedItems\" :key=\"index\">\n                        <slot name=\"item\" :item=\"item\" :options=\"getOptions(index)\"></slot>\n                    </template>\n                </div>\n            </slot>\n            <div v-if=\"showSpacer\" class=\"p-virtualscroller-spacer\" :style=\"spacerStyle\" v-bind=\"ptm('spacer')\"></div>\n            <div v-if=\"!loaderDisabled && showLoader && d_loading\" :class=\"loaderClass\" v-bind=\"ptm('loader')\">\n                <template v-if=\"$slots && $slots.loader\">\n                    <template v-for=\"(_, index) of loaderArr\" :key=\"index\">\n                        <slot name=\"loader\" :options=\"getLoaderOptions(index, isBoth() && { numCols: d_numItemsInViewport.cols })\"></slot>\n                    </template>\n                </template>\n                <slot name=\"loadingicon\">\n                    <SpinnerIcon spin class=\"p-virtualscroller-loading-icon\" v-bind=\"ptm('loadingIcon')\" />\n                </slot>\n            </div>\n        </div>\n    </template>\n    <template v-else>\n        <slot></slot>\n        <slot name=\"content\" :items=\"items\" :rows=\"items\" :columns=\"loadedColumns\"></slot>\n    </template>\n</template>\n\n<script>\nimport { findSingle, getHeight, getWidth, isVisible } from '@primeuix/utils/dom';\nimport SpinnerIcon from '@primevue/icons/spinner';\nimport BaseVirtualScroller from './BaseVirtualScroller.vue';\n\nexport default {\n    name: 'VirtualScroller',\n    extends: BaseVirtualScroller,\n    inheritAttrs: false,\n    emits: ['update:numToleratedItems', 'scroll', 'scroll-index-change', 'lazy-load'],\n    data() {\n        const both = this.isBoth();\n\n        return {\n            first: both ? { rows: 0, cols: 0 } : 0,\n            last: both ? { rows: 0, cols: 0 } : 0,\n            page: both ? { rows: 0, cols: 0 } : 0,\n            numItemsInViewport: both ? { rows: 0, cols: 0 } : 0,\n            lastScrollPos: both ? { top: 0, left: 0 } : 0,\n            d_numToleratedItems: this.numToleratedItems,\n            d_loading: this.loading,\n            loaderArr: [],\n            spacerStyle: {},\n            contentStyle: {}\n        };\n    },\n    element: null,\n    content: null,\n    lastScrollPos: null,\n    scrollTimeout: null,\n    resizeTimeout: null,\n    defaultWidth: 0,\n    defaultHeight: 0,\n    defaultContentWidth: 0,\n    defaultContentHeight: 0,\n    isRangeChanged: false,\n    lazyLoadState: {},\n    resizeListener: null,\n    initialized: false,\n    watch: {\n        numToleratedItems(newValue) {\n            this.d_numToleratedItems = newValue;\n        },\n        loading(newValue, oldValue) {\n            if (this.lazy && newValue !== oldValue && newValue !== this.d_loading) {\n                this.d_loading = newValue;\n            }\n        },\n        items(newValue, oldValue) {\n            if (!oldValue || oldValue.length !== (newValue || []).length) {\n                this.init();\n                this.calculateAutoSize();\n            }\n        },\n        itemSize() {\n            this.init();\n            this.calculateAutoSize();\n        },\n        orientation() {\n            this.lastScrollPos = this.isBoth() ? { top: 0, left: 0 } : 0;\n        },\n        scrollHeight() {\n            this.init();\n            this.calculateAutoSize();\n        },\n        scrollWidth() {\n            this.init();\n            this.calculateAutoSize();\n        }\n    },\n    mounted() {\n        this.viewInit();\n\n        this.lastScrollPos = this.isBoth() ? { top: 0, left: 0 } : 0;\n        this.lazyLoadState = this.lazyLoadState || {};\n    },\n    updated() {\n        !this.initialized && this.viewInit();\n    },\n    unmounted() {\n        this.unbindResizeListener();\n\n        this.initialized = false;\n    },\n    methods: {\n        viewInit() {\n            if (isVisible(this.element)) {\n                this.setContentEl(this.content);\n                this.init();\n                this.calculateAutoSize();\n                this.bindResizeListener();\n\n                this.defaultWidth = getWidth(this.element);\n                this.defaultHeight = getHeight(this.element);\n                this.defaultContentWidth = getWidth(this.content);\n                this.defaultContentHeight = getHeight(this.content);\n                this.initialized = true;\n            }\n        },\n        init() {\n            if (!this.disabled) {\n                this.setSize();\n                this.calculateOptions();\n                this.setSpacerSize();\n            }\n        },\n        isVertical() {\n            return this.orientation === 'vertical';\n        },\n        isHorizontal() {\n            return this.orientation === 'horizontal';\n        },\n        isBoth() {\n            return this.orientation === 'both';\n        },\n        scrollTo(options) {\n            //this.lastScrollPos = this.both ? { top: 0, left: 0 } : 0;\n            this.element && this.element.scrollTo(options);\n        },\n        scrollToIndex(index, behavior = 'auto') {\n            const both = this.isBoth();\n            const horizontal = this.isHorizontal();\n            const valid = both ? index.every((i) => i > -1) : index > -1;\n\n            if (valid) {\n                const first = this.first;\n                const { scrollTop = 0, scrollLeft = 0 } = this.element;\n                const { numToleratedItems } = this.calculateNumItems();\n                const contentPos = this.getContentPosition();\n                const itemSize = this.itemSize;\n                const calculateFirst = (_index = 0, _numT) => (_index <= _numT ? 0 : _index);\n                const calculateCoord = (_first, _size, _cpos) => _first * _size + _cpos;\n                const scrollTo = (left = 0, top = 0) => this.scrollTo({ left, top, behavior });\n                let newFirst = both ? { rows: 0, cols: 0 } : 0;\n                let isRangeChanged = false,\n                    isScrollChanged = false;\n\n                if (both) {\n                    newFirst = { rows: calculateFirst(index[0], numToleratedItems[0]), cols: calculateFirst(index[1], numToleratedItems[1]) };\n                    scrollTo(calculateCoord(newFirst.cols, itemSize[1], contentPos.left), calculateCoord(newFirst.rows, itemSize[0], contentPos.top));\n                    isScrollChanged = this.lastScrollPos.top !== scrollTop || this.lastScrollPos.left !== scrollLeft;\n                    isRangeChanged = newFirst.rows !== first.rows || newFirst.cols !== first.cols;\n                } else {\n                    newFirst = calculateFirst(index, numToleratedItems);\n                    horizontal ? scrollTo(calculateCoord(newFirst, itemSize, contentPos.left), scrollTop) : scrollTo(scrollLeft, calculateCoord(newFirst, itemSize, contentPos.top));\n                    isScrollChanged = this.lastScrollPos !== (horizontal ? scrollLeft : scrollTop);\n                    isRangeChanged = newFirst !== first;\n                }\n\n                this.isRangeChanged = isRangeChanged;\n                isScrollChanged && (this.first = newFirst);\n            }\n        },\n        scrollInView(index, to, behavior = 'auto') {\n            if (to) {\n                const both = this.isBoth();\n                const horizontal = this.isHorizontal();\n                const valid = both ? index.every((i) => i > -1) : index > -1;\n\n                if (valid) {\n                    const { first, viewport } = this.getRenderedRange();\n                    const scrollTo = (left = 0, top = 0) => this.scrollTo({ left, top, behavior });\n                    const isToStart = to === 'to-start';\n                    const isToEnd = to === 'to-end';\n\n                    if (isToStart) {\n                        if (both) {\n                            if (viewport.first.rows - first.rows > index[0]) {\n                                scrollTo(viewport.first.cols * this.itemSize[1], (viewport.first.rows - 1) * this.itemSize[0]);\n                            } else if (viewport.first.cols - first.cols > index[1]) {\n                                scrollTo((viewport.first.cols - 1) * this.itemSize[1], viewport.first.rows * this.itemSize[0]);\n                            }\n                        } else {\n                            if (viewport.first - first > index) {\n                                const pos = (viewport.first - 1) * this.itemSize;\n\n                                horizontal ? scrollTo(pos, 0) : scrollTo(0, pos);\n                            }\n                        }\n                    } else if (isToEnd) {\n                        if (both) {\n                            if (viewport.last.rows - first.rows <= index[0] + 1) {\n                                scrollTo(viewport.first.cols * this.itemSize[1], (viewport.first.rows + 1) * this.itemSize[0]);\n                            } else if (viewport.last.cols - first.cols <= index[1] + 1) {\n                                scrollTo((viewport.first.cols + 1) * this.itemSize[1], viewport.first.rows * this.itemSize[0]);\n                            }\n                        } else {\n                            if (viewport.last - first <= index + 1) {\n                                const pos = (viewport.first + 1) * this.itemSize;\n\n                                horizontal ? scrollTo(pos, 0) : scrollTo(0, pos);\n                            }\n                        }\n                    }\n                }\n            } else {\n                this.scrollToIndex(index, behavior);\n            }\n        },\n        getRenderedRange() {\n            const calculateFirstInViewport = (_pos, _size) => Math.floor(_pos / (_size || _pos));\n\n            let firstInViewport = this.first;\n            let lastInViewport = 0;\n\n            if (this.element) {\n                const both = this.isBoth();\n                const horizontal = this.isHorizontal();\n                const { scrollTop, scrollLeft } = this.element;\n\n                if (both) {\n                    firstInViewport = { rows: calculateFirstInViewport(scrollTop, this.itemSize[0]), cols: calculateFirstInViewport(scrollLeft, this.itemSize[1]) };\n                    lastInViewport = { rows: firstInViewport.rows + this.numItemsInViewport.rows, cols: firstInViewport.cols + this.numItemsInViewport.cols };\n                } else {\n                    const scrollPos = horizontal ? scrollLeft : scrollTop;\n\n                    firstInViewport = calculateFirstInViewport(scrollPos, this.itemSize);\n                    lastInViewport = firstInViewport + this.numItemsInViewport;\n                }\n            }\n\n            return {\n                first: this.first,\n                last: this.last,\n                viewport: {\n                    first: firstInViewport,\n                    last: lastInViewport\n                }\n            };\n        },\n        calculateNumItems() {\n            const both = this.isBoth();\n            const horizontal = this.isHorizontal();\n            const itemSize = this.itemSize;\n            const contentPos = this.getContentPosition();\n            const contentWidth = this.element ? this.element.offsetWidth - contentPos.left : 0;\n            const contentHeight = this.element ? this.element.offsetHeight - contentPos.top : 0;\n            const calculateNumItemsInViewport = (_contentSize, _itemSize) => Math.ceil(_contentSize / (_itemSize || _contentSize));\n            const calculateNumToleratedItems = (_numItems) => Math.ceil(_numItems / 2);\n            const numItemsInViewport = both\n                ? { rows: calculateNumItemsInViewport(contentHeight, itemSize[0]), cols: calculateNumItemsInViewport(contentWidth, itemSize[1]) }\n                : calculateNumItemsInViewport(horizontal ? contentWidth : contentHeight, itemSize);\n\n            const numToleratedItems = this.d_numToleratedItems || (both ? [calculateNumToleratedItems(numItemsInViewport.rows), calculateNumToleratedItems(numItemsInViewport.cols)] : calculateNumToleratedItems(numItemsInViewport));\n\n            return { numItemsInViewport, numToleratedItems };\n        },\n        calculateOptions() {\n            const both = this.isBoth();\n            const first = this.first;\n            const { numItemsInViewport, numToleratedItems } = this.calculateNumItems();\n            const calculateLast = (_first, _num, _numT, _isCols = false) => this.getLast(_first + _num + (_first < _numT ? 2 : 3) * _numT, _isCols);\n            const last = both\n                ? { rows: calculateLast(first.rows, numItemsInViewport.rows, numToleratedItems[0]), cols: calculateLast(first.cols, numItemsInViewport.cols, numToleratedItems[1], true) }\n                : calculateLast(first, numItemsInViewport, numToleratedItems);\n\n            this.last = last;\n            this.numItemsInViewport = numItemsInViewport;\n            this.d_numToleratedItems = numToleratedItems;\n            this.$emit('update:numToleratedItems', this.d_numToleratedItems);\n\n            if (this.showLoader) {\n                this.loaderArr = both ? Array.from({ length: numItemsInViewport.rows }).map(() => Array.from({ length: numItemsInViewport.cols })) : Array.from({ length: numItemsInViewport });\n            }\n\n            if (this.lazy) {\n                Promise.resolve().then(() => {\n                    this.lazyLoadState = {\n                        first: this.step ? (both ? { rows: 0, cols: first.cols } : 0) : first,\n                        last: Math.min(this.step ? this.step : last, this.items?.length || 0)\n                    };\n\n                    this.$emit('lazy-load', this.lazyLoadState);\n                });\n            }\n        },\n        calculateAutoSize() {\n            if (this.autoSize && !this.d_loading) {\n                Promise.resolve().then(() => {\n                    if (this.content) {\n                        const both = this.isBoth();\n                        const horizontal = this.isHorizontal();\n                        const vertical = this.isVertical();\n\n                        this.content.style.minHeight = this.content.style.minWidth = 'auto';\n                        this.content.style.position = 'relative';\n                        this.element.style.contain = 'none';\n\n                        /*const [contentWidth, contentHeight] = [getWidth(this.content), getHeight(this.content)];\n\n                        contentWidth !== this.defaultContentWidth && (this.element.style.width = '');\n                        contentHeight !== this.defaultContentHeight && (this.element.style.height = '');*/\n\n                        const [width, height] = [getWidth(this.element), getHeight(this.element)];\n\n                        (both || horizontal) && (this.element.style.width = width < this.defaultWidth ? width + 'px' : this.scrollWidth || this.defaultWidth + 'px');\n                        (both || vertical) && (this.element.style.height = height < this.defaultHeight ? height + 'px' : this.scrollHeight || this.defaultHeight + 'px');\n\n                        this.content.style.minHeight = this.content.style.minWidth = '';\n                        this.content.style.position = '';\n                        this.element.style.contain = '';\n                    }\n                });\n            }\n        },\n        getLast(last = 0, isCols) {\n            return this.items ? Math.min(isCols ? (this.columns || this.items[0])?.length || 0 : this.items?.length || 0, last) : 0;\n        },\n        getContentPosition() {\n            if (this.content) {\n                const style = getComputedStyle(this.content);\n                const left = parseFloat(style.paddingLeft) + Math.max(parseFloat(style.left) || 0, 0);\n                const right = parseFloat(style.paddingRight) + Math.max(parseFloat(style.right) || 0, 0);\n                const top = parseFloat(style.paddingTop) + Math.max(parseFloat(style.top) || 0, 0);\n                const bottom = parseFloat(style.paddingBottom) + Math.max(parseFloat(style.bottom) || 0, 0);\n\n                return { left, right, top, bottom, x: left + right, y: top + bottom };\n            }\n\n            return { left: 0, right: 0, top: 0, bottom: 0, x: 0, y: 0 };\n        },\n        setSize() {\n            if (this.element) {\n                const both = this.isBoth();\n                const horizontal = this.isHorizontal();\n                const parentElement = this.element.parentElement;\n                const width = this.scrollWidth || `${this.element.offsetWidth || parentElement.offsetWidth}px`;\n                const height = this.scrollHeight || `${this.element.offsetHeight || parentElement.offsetHeight}px`;\n                const setProp = (_name, _value) => (this.element.style[_name] = _value);\n\n                if (both || horizontal) {\n                    setProp('height', height);\n                    setProp('width', width);\n                } else {\n                    setProp('height', height);\n                }\n            }\n        },\n        setSpacerSize() {\n            const items = this.items;\n\n            if (items) {\n                const both = this.isBoth();\n                const horizontal = this.isHorizontal();\n                const contentPos = this.getContentPosition();\n                const setProp = (_name, _value, _size, _cpos = 0) => (this.spacerStyle = { ...this.spacerStyle, ...{ [`${_name}`]: (_value || []).length * _size + _cpos + 'px' } });\n\n                if (both) {\n                    setProp('height', items, this.itemSize[0], contentPos.y);\n                    setProp('width', this.columns || items[1], this.itemSize[1], contentPos.x);\n                } else {\n                    horizontal ? setProp('width', this.columns || items, this.itemSize, contentPos.x) : setProp('height', items, this.itemSize, contentPos.y);\n                }\n            }\n        },\n        setContentPosition(pos) {\n            if (this.content && !this.appendOnly) {\n                const both = this.isBoth();\n                const horizontal = this.isHorizontal();\n                const first = pos ? pos.first : this.first;\n                const calculateTranslateVal = (_first, _size) => _first * _size;\n                const setTransform = (_x = 0, _y = 0) => (this.contentStyle = { ...this.contentStyle, ...{ transform: `translate3d(${_x}px, ${_y}px, 0)` } });\n\n                if (both) {\n                    setTransform(calculateTranslateVal(first.cols, this.itemSize[1]), calculateTranslateVal(first.rows, this.itemSize[0]));\n                } else {\n                    const translateVal = calculateTranslateVal(first, this.itemSize);\n\n                    horizontal ? setTransform(translateVal, 0) : setTransform(0, translateVal);\n                }\n            }\n        },\n        onScrollPositionChange(event) {\n            const target = event.target;\n            const both = this.isBoth();\n            const horizontal = this.isHorizontal();\n            const contentPos = this.getContentPosition();\n            const calculateScrollPos = (_pos, _cpos) => (_pos ? (_pos > _cpos ? _pos - _cpos : _pos) : 0);\n            const calculateCurrentIndex = (_pos, _size) => Math.floor(_pos / (_size || _pos));\n\n            const calculateTriggerIndex = (_currentIndex, _first, _last, _num, _numT, _isScrollDownOrRight) => {\n                return _currentIndex <= _numT ? _numT : _isScrollDownOrRight ? _last - _num - _numT : _first + _numT - 1;\n            };\n\n            const calculateFirst = (_currentIndex, _triggerIndex, _first, _last, _num, _numT, _isScrollDownOrRight) => {\n                if (_currentIndex <= _numT) return 0;\n                else return Math.max(0, _isScrollDownOrRight ? (_currentIndex < _triggerIndex ? _first : _currentIndex - _numT) : _currentIndex > _triggerIndex ? _first : _currentIndex - 2 * _numT);\n            };\n\n            const calculateLast = (_currentIndex, _first, _last, _num, _numT, _isCols) => {\n                let lastValue = _first + _num + 2 * _numT;\n\n                if (_currentIndex >= _numT) {\n                    lastValue += _numT + 1;\n                }\n\n                return this.getLast(lastValue, _isCols);\n            };\n\n            const scrollTop = calculateScrollPos(target.scrollTop, contentPos.top);\n            const scrollLeft = calculateScrollPos(target.scrollLeft, contentPos.left);\n\n            let newFirst = both ? { rows: 0, cols: 0 } : 0;\n            let newLast = this.last;\n            let isRangeChanged = false;\n            let newScrollPos = this.lastScrollPos;\n\n            if (both) {\n                const isScrollDown = this.lastScrollPos.top <= scrollTop;\n                const isScrollRight = this.lastScrollPos.left <= scrollLeft;\n\n                if (!this.appendOnly || (this.appendOnly && (isScrollDown || isScrollRight))) {\n                    const currentIndex = { rows: calculateCurrentIndex(scrollTop, this.itemSize[0]), cols: calculateCurrentIndex(scrollLeft, this.itemSize[1]) };\n                    const triggerIndex = {\n                        rows: calculateTriggerIndex(currentIndex.rows, this.first.rows, this.last.rows, this.numItemsInViewport.rows, this.d_numToleratedItems[0], isScrollDown),\n                        cols: calculateTriggerIndex(currentIndex.cols, this.first.cols, this.last.cols, this.numItemsInViewport.cols, this.d_numToleratedItems[1], isScrollRight)\n                    };\n\n                    newFirst = {\n                        rows: calculateFirst(currentIndex.rows, triggerIndex.rows, this.first.rows, this.last.rows, this.numItemsInViewport.rows, this.d_numToleratedItems[0], isScrollDown),\n                        cols: calculateFirst(currentIndex.cols, triggerIndex.cols, this.first.cols, this.last.cols, this.numItemsInViewport.cols, this.d_numToleratedItems[1], isScrollRight)\n                    };\n                    newLast = {\n                        rows: calculateLast(currentIndex.rows, newFirst.rows, this.last.rows, this.numItemsInViewport.rows, this.d_numToleratedItems[0]),\n                        cols: calculateLast(currentIndex.cols, newFirst.cols, this.last.cols, this.numItemsInViewport.cols, this.d_numToleratedItems[1], true)\n                    };\n\n                    isRangeChanged = newFirst.rows !== this.first.rows || newLast.rows !== this.last.rows || newFirst.cols !== this.first.cols || newLast.cols !== this.last.cols || this.isRangeChanged;\n                    newScrollPos = { top: scrollTop, left: scrollLeft };\n                }\n            } else {\n                const scrollPos = horizontal ? scrollLeft : scrollTop;\n                const isScrollDownOrRight = this.lastScrollPos <= scrollPos;\n\n                if (!this.appendOnly || (this.appendOnly && isScrollDownOrRight)) {\n                    const currentIndex = calculateCurrentIndex(scrollPos, this.itemSize);\n                    const triggerIndex = calculateTriggerIndex(currentIndex, this.first, this.last, this.numItemsInViewport, this.d_numToleratedItems, isScrollDownOrRight);\n\n                    newFirst = calculateFirst(currentIndex, triggerIndex, this.first, this.last, this.numItemsInViewport, this.d_numToleratedItems, isScrollDownOrRight);\n                    newLast = calculateLast(currentIndex, newFirst, this.last, this.numItemsInViewport, this.d_numToleratedItems);\n                    isRangeChanged = newFirst !== this.first || newLast !== this.last || this.isRangeChanged;\n                    newScrollPos = scrollPos;\n                }\n            }\n\n            return {\n                first: newFirst,\n                last: newLast,\n                isRangeChanged,\n                scrollPos: newScrollPos\n            };\n        },\n        onScrollChange(event) {\n            const { first, last, isRangeChanged, scrollPos } = this.onScrollPositionChange(event);\n\n            if (isRangeChanged) {\n                const newState = { first, last };\n\n                this.setContentPosition(newState);\n\n                this.first = first;\n                this.last = last;\n                this.lastScrollPos = scrollPos;\n\n                this.$emit('scroll-index-change', newState);\n\n                if (this.lazy && this.isPageChanged(first)) {\n                    const lazyLoadState = {\n                        first: this.step ? Math.min(this.getPageByFirst(first) * this.step, (this.items?.length || 0) - this.step) : first,\n                        last: Math.min(this.step ? (this.getPageByFirst(first) + 1) * this.step : last, this.items?.length || 0)\n                    };\n                    const isLazyStateChanged = this.lazyLoadState.first !== lazyLoadState.first || this.lazyLoadState.last !== lazyLoadState.last;\n\n                    isLazyStateChanged && this.$emit('lazy-load', lazyLoadState);\n                    this.lazyLoadState = lazyLoadState;\n                }\n            }\n        },\n        onScroll(event) {\n            this.$emit('scroll', event);\n\n            if (this.delay) {\n                if (this.scrollTimeout) {\n                    clearTimeout(this.scrollTimeout);\n                }\n\n                if (this.isPageChanged()) {\n                    if (!this.d_loading && this.showLoader) {\n                        const { isRangeChanged } = this.onScrollPositionChange(event);\n                        const changed = isRangeChanged || (this.step ? this.isPageChanged() : false);\n\n                        changed && (this.d_loading = true);\n                    }\n\n                    this.scrollTimeout = setTimeout(() => {\n                        this.onScrollChange(event);\n\n                        if (this.d_loading && this.showLoader && (!this.lazy || this.loading === undefined)) {\n                            this.d_loading = false;\n                            this.page = this.getPageByFirst();\n                        }\n                    }, this.delay);\n                }\n            } else {\n                this.onScrollChange(event);\n            }\n        },\n        onResize() {\n            if (this.resizeTimeout) {\n                clearTimeout(this.resizeTimeout);\n            }\n\n            this.resizeTimeout = setTimeout(() => {\n                if (isVisible(this.element)) {\n                    const both = this.isBoth();\n                    const vertical = this.isVertical();\n                    const horizontal = this.isHorizontal();\n                    const [width, height] = [getWidth(this.element), getHeight(this.element)];\n                    const [isDiffWidth, isDiffHeight] = [width !== this.defaultWidth, height !== this.defaultHeight];\n                    const reinit = both ? isDiffWidth || isDiffHeight : horizontal ? isDiffWidth : vertical ? isDiffHeight : false;\n\n                    if (reinit) {\n                        this.d_numToleratedItems = this.numToleratedItems;\n                        this.defaultWidth = width;\n                        this.defaultHeight = height;\n                        this.defaultContentWidth = getWidth(this.content);\n                        this.defaultContentHeight = getHeight(this.content);\n\n                        this.init();\n                    }\n                }\n            }, this.resizeDelay);\n        },\n        bindResizeListener() {\n            if (!this.resizeListener) {\n                this.resizeListener = this.onResize.bind(this);\n\n                window.addEventListener('resize', this.resizeListener);\n                window.addEventListener('orientationchange', this.resizeListener);\n            }\n        },\n        unbindResizeListener() {\n            if (this.resizeListener) {\n                window.removeEventListener('resize', this.resizeListener);\n                window.removeEventListener('orientationchange', this.resizeListener);\n                this.resizeListener = null;\n            }\n        },\n        getOptions(renderedIndex) {\n            const count = (this.items || []).length;\n            const index = this.isBoth() ? this.first.rows + renderedIndex : this.first + renderedIndex;\n\n            return {\n                index,\n                count,\n                first: index === 0,\n                last: index === count - 1,\n                even: index % 2 === 0,\n                odd: index % 2 !== 0\n            };\n        },\n        getLoaderOptions(index, extOptions) {\n            let count = this.loaderArr.length;\n\n            return {\n                index,\n                count,\n                first: index === 0,\n                last: index === count - 1,\n                even: index % 2 === 0,\n                odd: index % 2 !== 0,\n                ...extOptions\n            };\n        },\n        getPageByFirst(first) {\n            return Math.floor(((first ?? this.first) + this.d_numToleratedItems * 4) / (this.step || 1));\n        },\n        isPageChanged(first) {\n            return this.step ? this.page !== this.getPageByFirst(first ?? this.first) : true;\n        },\n        setContentEl(el) {\n            this.content = el || this.content || findSingle(this.element, '[data-pc-section=\"content\"]');\n        },\n        elementRef(el) {\n            this.element = el;\n        },\n        contentRef(el) {\n            this.content = el;\n        }\n    },\n    computed: {\n        containerClass() {\n            return [\n                'p-virtualscroller',\n                this.class,\n                {\n                    'p-virtualscroller-inline': this.inline,\n                    'p-virtualscroller-both p-both-scroll': this.isBoth(),\n                    'p-virtualscroller-horizontal p-horizontal-scroll': this.isHorizontal()\n                }\n            ];\n        },\n        contentClass() {\n            return [\n                'p-virtualscroller-content',\n                {\n                    'p-virtualscroller-loading': this.d_loading\n                }\n            ];\n        },\n        loaderClass() {\n            return [\n                'p-virtualscroller-loader',\n                {\n                    'p-virtualscroller-loader-mask': !this.$slots.loader\n                }\n            ];\n        },\n        loadedItems() {\n            if (this.items && !this.d_loading) {\n                if (this.isBoth()) return this.items.slice(this.appendOnly ? 0 : this.first.rows, this.last.rows).map((item) => (this.columns ? item : item.slice(this.appendOnly ? 0 : this.first.cols, this.last.cols)));\n                else if (this.isHorizontal() && this.columns) return this.items;\n                else return this.items.slice(this.appendOnly ? 0 : this.first, this.last);\n            }\n\n            return [];\n        },\n        loadedRows() {\n            return this.d_loading ? (this.loaderDisabled ? this.loaderArr : []) : this.loadedItems;\n        },\n        loadedColumns() {\n            if (this.columns) {\n                const both = this.isBoth();\n                const horizontal = this.isHorizontal();\n\n                if (both || horizontal) {\n                    return this.d_loading && this.loaderDisabled ? (both ? this.loaderArr[0] : this.loaderArr) : this.columns.slice(both ? this.first.cols : this.first, both ? this.last.cols : this.last);\n                }\n            }\n\n            return this.columns;\n        }\n    },\n    components: {\n        SpinnerIcon: SpinnerIcon\n    }\n};\n</script>\n"],
  "mappings": "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",
  "names": ["theme", "_ref", "dt", "concat", "BaseStyle", "extend", "name", "name", "BaseComponent", "props", "id", "type", "String", "style", "items", "Array", "itemSize", "Number", "scrollHeight", "scrollWidth", "orientation", "numToleratedItems", "delay", "resizeDelay", "lazy", "Boolean", "disabled", "loaderDisabled", "columns", "loading", "showSpacer", "showLoader", "tabindex", "inline", "step", "appendOnly", "autoSize", "VirtualScrollerStyle", "provide", "$pcVirtualScroller", "$parentInstance", "beforeMount", "_this$$primevueConfig", "loadCSS", "nonce", "$primevueConfig", "csp", "script", "BaseVirtualScroller", "inheritAttrs", "emits", "data", "both", "isBoth", "first", "rows", "cols", "last", "page", "numItemsInViewport", "lastScrollPos", "top", "left", "d_numToleratedItems", "d_loading", "loaderArr", "spacerStyle", "contentStyle", "element", "content", "scrollTimeout", "resizeTimeout", "defaultWidth", "defaultHeight", "defaultContentWidth", "defaultContentHeight", "isRangeChanged", "lazyLoadState", "resizeListener", "initialized", "watch", "newValue", "oldValue", "length", "init", "calculateAutoSize", "mounted", "viewInit", "updated", "unmounted", "unbindResizeListener", "methods", "isVisible", "setContentEl", "bindResizeListener", "getWidth", "getHeight", "setSize", "calculateOptions", "setSpacerSize", "isVertical", "isHorizontal", "scrollTo", "options", "scrollToIndex", "index", "_this", "behavior", "arguments", "undefined", "horizontal", "valid", "every", "i", "_this$element", "_this$element$scrollT", "scrollTop", "_this$element$scrollL", "scrollLeft", "_this$calculateNumIte", "calculateNumItems", "contentPos", "getContentPosition", "calculateFirst", "_index", "_numT", "calculateCoord", "_first", "_size", "_cpos", "newFirst", "isScrollChanged", "scrollInView", "to", "_this2", "_this$getRenderedRang", "getRenderedRange", "viewport", "isToStart", "isToEnd", "pos", "calculateFirstInViewport", "_pos", "Math", "floor", "firstInViewport", "lastInViewport", "_this$element2", "scrollPos", "contentWidth", "offsetWidth", "contentHeight", "offsetHeight", "calculateNumItemsInViewport", "_contentSize", "_itemSize", "ceil", "calculateNumToleratedItems", "_numItems", "_this3", "_this$calculateNumIte2", "calculateLast", "_num", "_isCols", "getLast", "$emit", "from", "map", "Promise", "resolve", "then", "_this3$items", "min", "_this4", "vertical", "minHeight", "minWidth", "position", "contain", "_ref", "width", "height", "_ref2", "_this$items", "isCols", "getComputedStyle", "parseFloat", "paddingLeft", "max", "right", "paddingRight", "paddingTop", "bottom", "paddingBottom", "x", "y", "_this5", "parentElement", "concat", "setProp", "_name", "_value", "_this6", "_objectSpread", "_defineProperty", "setContentPosition", "_this7", "calculateTranslateVal", "setTransform", "_x", "_y", "transform", "translateVal", "onScrollPositionChange", "event", "_this8", "target", "calculateScrollPos", "calculateCurrentIndex", "calculateTriggerIndex", "_currentIndex", "_last", "_isScrollDownOrRight", "_triggerIndex", "lastValue", "newLast", "newScrollPos", "isScrollDown", "isScrollRight", "currentIndex", "triggerIndex", "isScrollDownOrRight", "onScrollChange", "_this$onScrollPositio", "newState", "isPageChanged", "_this$items2", "_this$items3", "getPageByFirst", "isLazyStateChanged", "onScroll", "_this9", "clearTimeout", "_this$onScrollPositio2", "changed", "setTimeout", "onResize", "_this10", "_ref3", "isDiffWidth", "isDiffHeight", "reinit", "bind", "window", "addEventListener", "removeEventListener", "getOptions", "renderedIndex", "count", "even", "odd", "getLoaderOptions", "extOptions", "el", "findSingle", "elementRef", "contentRef", "computed", "containerClass", "contentClass", "loaderClass", "$slots", "loader", "loadedItems", "_this11", "slice", "item", "loadedRows", "loadedColumns", "components", "SpinnerIcon", "_ctx", "_openBlock", "_createElementBlock", "_mergeProps", "ref", "$options", "apply", "ptmi", "_renderSlot", "styleClass", "getItemOptions", "$data", "_createElementVNode", "ptm", "_Fragment", "_renderList", "key", "_", "numCols", "d_numItemsInViewport", "_createVNode", "_component_SpinnerIcon", "spin"]
}
